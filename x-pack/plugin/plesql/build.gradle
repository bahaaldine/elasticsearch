/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

apply plugin: 'elasticsearch.internal-es-plugin'
apply plugin: 'elasticsearch.internal-cluster-test'
apply plugin: 'elasticsearch.string-templates'
apply plugin: 'elasticsearch.publish'

esplugin {
  name 'x-pack-plesql'
  description 'A plugin to handle PL|ES|QL queries'
  classname 'org.elasticsearch.xpack.plesql.PlEsqlPlugin'
  extendedPlugins = ['x-pack-core']
}

base {
  archivesName = 'x-pack-plesql'
}

test {
  jvmArgs += [
    '--enable-native-access=ALL-UNNAMED',
    '--add-modules=jdk.incubator.vector'
  ]
}

dependencies {
  compileOnly 'commons-logging:commons-logging:1.2'

  testImplementation "org.apache.logging.log4j:log4j-core:${versions.log4j}"
  testImplementation "org.apache.logging.log4j:log4j-api:${versions.log4j}"

  api "org.antlr:antlr4-runtime:${versions.antlr4}"
  api project(path: xpackModule('mapper-version'))

  compileOnly project(':x-pack:plugin:esql')
  compileOnly project(path: xpackModule('core'))

  testImplementation project(':x-pack:plugin:esql-core')

  testImplementation project(':test:framework')
  internalClusterTestImplementation project(":modules:mapper-extras")
}
configurations {n
  regenerate
}

dependencies {
  regenerate "org.antlr:antlr4:${versions.antlr4}"
}

String grammarPath = 'src/main/java/org/elasticsearch/xpack/plesql/parser'
String outputPath = 'src/main/java/org/elasticsearch/xpack/plesql/parser'

tasks.register("cleanGenerated", Delete) {
  delete fileTree(grammarPath) {
    include '*.tokens'
  }
  delete fileTree(outputPath) {
    include 'PlEsqlProcedure*.java'
  }
}

tasks.register("regenGrammar", JavaExec) {
  dependsOn "cleanGenerated"
  mainClass = 'org.antlr.v4.Tool'
  classpath = configurations.regenerate
  systemProperty 'file.encoding', 'UTF-8'
  systemProperty 'user.language', 'en'
  systemProperty 'user.country', 'US'
  systemProperty 'user.variant', ''
  args '-Werror',
    '-package', 'org.elasticsearch.xpack.plesql.parser',
    '-listener',
    '-visitor',
    '-o', outputPath,
    "${file(grammarPath)}/PlEsqlProcedure.g4"  // Single grammar file
}

tasks.register("regen") {
  dependsOn "regenGrammar"
  doLast {
    // Move tokens to grammar directory
    ant.move(file: "${outputPath}/PlEsqlProcedure.tokens", toDir: grammarPath)

    // Replace the header with Elasticsearch license
    ant.replaceregexp(
      match: '// Generated from .* by ANTLR.*',  // Match the autogenerated ANTLR header more specifically
      replace: '''/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
''',
      encoding: 'UTF-8'
    ) {
      fileset(dir: outputPath, includes: 'PlEsqlProcedure*.java')
    }

    // Replace wildcard imports in PlEsqlProcedureLexer.java
    ant.replaceregexp(
      match: 'import org\\.antlr\\.v4\\.runtime\\.\\*;',
      replace: '''import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.RuntimeMetaData;
import org.antlr.v4.runtime.Vocabulary;
import org.antlr.v4.runtime.VocabularyImpl;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.atn.ATN;
import org.antlr.v4.runtime.atn.ATNDeserializer;
import org.antlr.v4.runtime.atn.LexerATNSimulator;
import org.antlr.v4.runtime.atn.PredictionContextCache;
import org.antlr.v4.runtime.dfa.DFA;''',
      encoding: 'UTF-8'
    ) {
      fileset(dir: outputPath, includes: 'PlEsqlProcedureLexer*.java')
    }

    // Replace wildcard imports in PlEsqlProcedureParser.java
    ant.replaceregexp(
      match: 'import org\\.antlr\\.v4\\.runtime\\.\\*;',
      replace: '''import org.antlr.v4.runtime.FailedPredicateException;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.RuntimeMetaData;
import org.antlr.v4.runtime.atn.ATN;
import org.antlr.v4.runtime.atn.ATNDeserializer;
import org.antlr.v4.runtime.atn.ParserATNSimulator;
import org.antlr.v4.runtime.atn.PredictionContextCache;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.Vocabulary;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.VocabularyImpl;
import org.antlr.v4.runtime.tree.ParseTreeListener;
import org.antlr.v4.runtime.tree.ParseTreeVisitor;
import org.antlr.v4.runtime.tree.TerminalNode;''',
      encoding: 'UTF-8'
    ) {
      fileset(dir: outputPath, includes: 'PlEsqlProcedureParser*.java')
    }
  }
}

// Scaffold a new single function
tasks.register("generateFunction") {
  doLast {
    def name = project.findProperty("functionName")
    if (!name) throw new GradleException("Specify -PfunctionName=MyFunction")

    def className = name.capitalize()
    def destFile = file("src/main/java/org/elasticsearch/xpack/plesql/functions/community/${className}.java")
    destFile.parentFile.mkdirs()
    destFile.text = """/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.plesql.functions.community;

import org.elasticsearch.xpack.plesql.functions.api.FunctionSpec;
import org.elasticsearch.xpack.plesql.functions.api.FunctionParam;
import org.elasticsearch.xpack.plesql.functions.api.FunctionReturn;
import org.elasticsearch.xpack.plesql.functions.api.FunctionCategory;
import org.elasticsearch.xpack.plesql.context.ExecutionContext;
import org.elasticsearch.xpack.plesql.functions.builtin.BuiltInFunctionDefinition;
import org.elasticsearch.xpack.plesql.functions.Parameter;
import org.elasticsearch.xpack.plesql.functions.ParameterMode;
import org.elasticsearch.action.ActionListener;

import java.util.Collections;
import java.util.List;

@FunctionSpec(
    name = "${name.toUpperCase()}",
    description = "Describe what this function does.",
    parameters = {
        @FunctionParam(name = "input", type = "STRING", description = "Input value")
    },
    returnType = @FunctionReturn(type = "STRING", description = "The result of the transformation"),
    examples = {
        "${name.toUpperCase()}('hello') -> 'olleh'"
    },
    category = FunctionCategory.UTILITY
)
public class ${className} {

    public static void register(ExecutionContext context) {
        context.declareFunction("${name.toUpperCase()}",
            Collections.singletonList(new Parameter("input", "STRING", ParameterMode.IN)),
            new BuiltInFunctionDefinition("${name.toUpperCase()}", ${className}::execute)
        );
    }

    private static void execute(List<Object> args, ActionListener<Object> listener) {
        if (args.size() != 1 || !(args.get(0) instanceof String)) {
            listener.onFailure(new IllegalArgumentException("Expected a single STRING argument"));
        } else {
            String input = (String) args.get(0);
            listener.onResponse(new StringBuilder(input).reverse().toString());
        }
    }
}
"""
    println "✅ Created single function class at: ${destFile}"

    def loaderFile = file("src/main/java/org/elasticsearch/xpack/plesql/functions/community/FunctionLoader.java")
    def loaderText = loaderFile.text
    def insertLine = "        classes.add(org.elasticsearch.xpack.plesql.functions.community.${className}.class);"

    if (!loaderText.contains(insertLine)) {
        loaderText = loaderText.replaceFirst(
            /List<Class<?>> classes = new ArrayList\(\);/,
            "List<Class<?>> classes = new ArrayList();\n${insertLine}"
        )
        loaderFile.text = loaderText
        println "✅ Registered ${className} in FunctionLoader"
    }

    // Update registry.txt
    def registryDir = file("src/main/resources/org/elasticsearch/xpack/plesql/functions/community")
    registryDir.mkdirs()
    def registryFile = file("${registryDir}/registry.txt")
    def entry = "org.elasticsearch.xpack.plesql.functions.community.${className}\n"
    if (!registryFile.exists()) {
        registryFile.text = entry
    } else {
        def registryText = registryFile.text
        if (!registryText.contains("org.elasticsearch.xpack.plesql.functions.community.${className}")) {
            registryFile.append(entry)
        }
    }
  }
}

// Scaffold a new function collection
tasks.register("generateFunctionCollection") {
  doLast {
    def name = project.findProperty("functionName")
    if (!name) throw new GradleException("Specify -PfunctionName=MyFunctions")

    def className = name.capitalize()
    def destFile = file("src/main/java/org/elasticsearch/xpack/plesql/functions/community/${className}.java")
    destFile.parentFile.mkdirs()
    destFile.text = """/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.plesql.functions.community;

import org.elasticsearch.xpack.plesql.functions.api.FunctionCollectionSpec;
import org.elasticsearch.xpack.plesql.functions.api.FunctionSpec;
import org.elasticsearch.xpack.plesql.functions.api.FunctionParam;
import org.elasticsearch.xpack.plesql.functions.api.FunctionReturn;
import org.elasticsearch.xpack.plesql.functions.api.FunctionCategory;
import org.elasticsearch.xpack.plesql.context.ExecutionContext;
import org.elasticsearch.xpack.plesql.functions.builtin.BuiltInFunctionDefinition;
import org.elasticsearch.xpack.plesql.functions.Parameter;
import org.elasticsearch.xpack.plesql.functions.ParameterMode;
import org.elasticsearch.action.ActionListener;

import java.util.Collections;
import java.util.List;

@FunctionCollectionSpec(
    category = FunctionCategory.UTILITY,
    description = "Custom function collection: ${name}"
)
public class ${className} {

    public static void registerAll(ExecutionContext context) {
        registerSample(context);
    }

    @FunctionSpec(
        name = "${name.toUpperCase()}_SAMPLE",
        description = "A sample function in ${name}",
        parameters = {
            @FunctionParam(name = "input", type = "STRING", description = "Input value")
        },
        returnType = @FunctionReturn(type = "STRING", description = "Processed output"),
        examples = {
            "${name.toUpperCase()}_SAMPLE('abc') -> 'xyz'"
        },
        category = FunctionCategory.UTILITY
    )
    public static void registerSample(ExecutionContext context) {
        context.declareFunction("${name.toUpperCase()}_SAMPLE",
            Collections.singletonList(new Parameter("input", "STRING", ParameterMode.IN)),
            new BuiltInFunctionDefinition("${name.toUpperCase()}_SAMPLE", ${className}::executeSample)
        );
    }

    private static void executeSample(List<Object> args, ActionListener<Object> listener) {
        if (args.size() != 1 || (args.get(0) instanceof String) == false) {
            listener.onFailure(new IllegalArgumentException("Expected a single STRING argument"));
        } else {
            String input = (String) args.get(0);
            listener.onResponse(new StringBuilder(input).reverse().toString());
        }
    }
}
"""
    println "✅ Created function collection class at: ${destFile}"

    def loaderFile = file("src/main/java/org/elasticsearch/xpack/plesql/functions/community/FunctionLoader.java")
    def loaderText = loaderFile.text
    def insertLine = "        classes.add(org.elasticsearch.xpack.plesql.functions.community.${className}.class);"

    if (!loaderText.contains(insertLine)) {
        loaderText = loaderText.replaceFirst(
            /List<Class<?>> classes = new ArrayList\(\);/,
            "List<Class<?>> classes = new ArrayList();\n${insertLine}"
        )
        loaderFile.text = loaderText
        println "✅ Registered ${className} in FunctionLoader"
    }

    // Update registry.txt
    def registryDir = file("src/main/resources/org/elasticsearch/xpack/plesql/functions/community")
    registryDir.mkdirs()
    def registryFile = file("${registryDir}/registry.txt")
    def entry = "org.elasticsearch.xpack.plesql.functions.community.${className}\n"
    if (!registryFile.exists()) {
        registryFile.text = entry
    } else {
        def registryText = registryFile.text
        if (!registryText.contains("org.elasticsearch.xpack.plesql.functions.community.${className}")) {
            registryFile.append(entry)
        }
    }
  }
}
